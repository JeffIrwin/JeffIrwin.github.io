
{% include header.md %}

# Tarjan's bridge algorithm

## An iterative implementation

### 2024 Feb 04

Tarjan's bridge algorithm finds _bridges_ in a graph.  A bridge is an edge
whose removal would increase the number of connected components of a graph, i.e.
removing a bridge from a graph of 1 connected component would break it into 2
connected components.  I'll explain this more with figures later, but first
let's dive right into the algorithm.

Here is a non-recursive function that searches for a bridge in graph `g`, in the
component connected to node 0. The function returns the pair of nodes that make
up the first bridge found, or `[-1, -1]` if no bridges are found.

The input graph `g` is represented as a rank-2 array of size `NADJ_CAP` by `nn`,
where `NADJ_CAP` is the max number of adjacent nodes per node and `nn` is the
total number of nodes in the graph.  The slice `g[:,v]` lists the neighbors of
node `v`.  The graph `g` is accompanied by another array `num_adj`.  The number
of neighbors of node `v` is `num_adj[v]`.

<!-- Tab link buttons -->
<div class="tab">
  <button class="tablinks_0" onclick="open_tab_0(event, "syntran_0")" id="default_open_0">syntran</button>
  <button class="tablinks_0" onclick="open_tab_0(event, "c_0")">C</button>
</div>

<!-- Tab content -->
<div id="syntran_0" class="tabcontent_0">
{% highlight rust %}
fn get_bridge(g: [i32; :, :], num_adj: [i32; :]): [i32; :]
{
	// Stack for iterative (non-recursive) depth-first search
	let nn = size(num_adj, 0);
	let STACK_CAP = 16 * nn;
	let stack = [0; STACK_CAP];
	let sp = -1; // stack "pointer"

	// Push node 0 as root
	stack[(sp += 1)] = 0;

	let visited = [false; nn];
	let defer   = [false; nn];
	let parent  = [-1   ; nn];
	let low     = [-1   ; nn];
	let dists   = [-1   ; nn];

	let dist = 0;
	let found = false;
	let bridge = [-1, -1];
	while sp >= 0 and not found
	{
		let v = stack[(sp -= 1) + 1]; // pop
		if not visited[v]
		{
			low[v]   = dist;
			dists[v] = dist;
			dist += 1;
		}
		visited[v] = true;

		for iw in [0: num_adj[v]]
		{
			let w = g[iw, v];
			if w == parent[v]
			{
				// Do nothing
			}
			else if visited[w]
				low[v] = min(low[v], dists[w]);
			else
			{
				parent[w] = v;

				// re-push parent for deferred processing
				stack[(sp += 1)] = v;
				check_stack_cap(sp, STACK_CAP);
				defer[v] = true;

				// push child. order matters wrt parent
				stack[(sp += 1)] = w;
				check_stack_cap(sp, STACK_CAP);
			}
		}

		if defer[v]
		{
			for iw in [0: num_adj[v]]
			{
				let w = g[iw, v];
				if w != parent[v] and visited[w]
				{
					low[v] = min(low[v], low[w]);
					if (low[w] > dists[v])
					{
						bridge = [v, w];
						found = true;
					}
				}
			}
		}
	}
	let ans = bridge;
}
{% endhighlight %}
</div>

<!-- ******** -->

<div id="c_0" class="tabcontent_0">
{% highlight c %}
int* get_bridge(int* g, int* num_adj, int nn)
{
	// Stack for iterative (non-recursive) depth-first search
	int STACK_CAP = 16 * nn;
	int* stack = malloc(STACK_CAP * sizeof(int));
	memset(stack, 0, sizeof(stack));
	int sp = -1; // stack "pointer"

	// Push node 0 as root
	stack[(sp += 1)] = 0;

	bool* visited = malloc(nn * sizeof(bool));
	bool* defer   = malloc(nn * sizeof(bool));
	int*  parent  = malloc(nn * sizeof(int));
	int*  low     = malloc(nn * sizeof(int));
	int*  dists   = malloc(nn * sizeof(int));

	memset(visited, false, nn * sizeof(bool));
	memset(defer  , false, nn * sizeof(bool));
	memset(parent , -1   , nn * sizeof(int));
	memset(low    , -1   , nn * sizeof(int));
	memset(dists  , -1   , nn * sizeof(int));

	int dist = 0;
	bool found = false;
	int* bridge = malloc(2 * sizeof(int)); bridge[0] = -1; bridge[1] = -1;
	while (sp >= 0 && !found)
	{
		int v = stack[(sp -= 1) + 1]; // pop
		if (!visited[v])
		{
			low[v]   = dist;
			dists[v] = dist;
			dist += 1;
		}
		visited[v] = true;

		for (int iw = 0; iw < num_adj[v]; iw++)
		{
			int w = g[v * NADJ_CAP + iw];
			if (w == parent[v])
			{
				// Do nothing
			}
			else if (visited[w])
				low[v] = min(low[v], dists[w]);
			else
			{
				parent[w] = v;

				// Re-push parent for deferred processing
				stack[(sp += 1)] = v;
				//check_stack_cap(sp, STACK_CAP); // TODO
				defer[v] = true;

				// Push child. order matters wrt parent
				stack[(sp += 1)] = w;
				//check_stack_cap(sp, STACK_CAP); // TODO
			}
		}

		if (defer[v])
		{
			for (int iw = 0; iw < num_adj[v]; iw++)
			{
				int w = g[v * NADJ_CAP + iw];
				if ((w != parent[v]) && visited[w])
				{
					low[v] = min(low[v], low[w]);
					if (low[w] > dists[v])
					{
						bridge[0] = v; bridge[1] = w;
						found = true;
					}
				}
			}
		}
	}
	return bridge;
}
{% endhighlight %}
</div>

<!----------------------------------------------------------------------------->

<script>

    function open_tab_0(evt, tabName) {
        // Declare all variables
        var i, tabcontent, tablinks;

        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("tabcontent_0");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("tablinks_0");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
    }

    function open_tab_1(evt, tabName) {
        // Declare all variables
        var i, tabcontent, tablinks;

        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("tabcontent_1");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("tablinks_1");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
    }

    // Show only default tab(s) on page load
    document.getElementById("default_open_0").click();
    document.getElementById("default_open_1").click();

    // Change code block "figure" margins from ungodly 40px
    elems = document.getElementsByClassName("highlight");
    for (i = 0; i < elems.length; i++) {
        elems[i].style.margin = "0px";
        elems[i].style.tabSize = "4";
    }
</script>

<!----------------------------------------------------------------------------->

## Why iterative instead of recursive?

## What is a bridge?

## Reading the graph

## Calling the get_bridge() function

<!-- Tab link buttons -->
<div class="tab">
  <button class="tablinks_1" onclick="open_tab_1(event, "syntran_1")" id="default_open_1">syntran</button>
  <button class="tablinks_1" onclick="open_tab_1(event, "c_1")">C</button>
</div>

<!-- Tab content -->
<div id="syntran_1" class="tabcontent_1">
{% highlight rust %}
fn main(): i32
{
	read_aoc_graph(filename_glbl);

	let bridge = get_bridge(g_glbl, num_adj_glbl);
	if bridge[0] < 0
		println("No bridges were found");
	else
		println("Found bridge between nodes ", bridge, " = ",
				[names_glbl[bridge[0]], names_glbl[bridge[1]]]);

	let ans = 0;
}
{% endhighlight %}
</div>

<!-- ******** -->

<div id="c_1" class="tabcontent_1">
{% highlight c %}
int main()
{
	read_aoc_graph(filename_glbl);

	int* bridge = get_bridge(g_glbl, num_adj_glbl, num_nodes);
	if (bridge[0] < 0)
		println("No bridges were found");
	else
		printf("Found bridge between nodes [%d, %d] = [%s, %s]\n",
				bridge[0], bridge[1],
				names_glbl[bridge[0]], names_glbl[bridge[1]]);

	return 0;
}
{% endhighlight %}
</div>

