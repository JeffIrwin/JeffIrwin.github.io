
{% include header.md %}

# Tarjan's bridge algorithm

## An iterative implementation

### 2024 Feb 04

Here is a non-recursive function that searches for a bridge in graph `g`, in the
component connected to node 0. The function returns the pair of nodes that make
up the first bridge found, or `[-1, -1]` if no bridges are found.

<!-- Tab link buttons -->
<div class="tab">
  <button class="tablinks" onclick="openTab(event, 'syntran_0')" id="defaultOpen">syntran</button>
  <button class="tablinks" onclick="openTab(event, 'c_0')">C</button>
</div>

<!-- Tab content -->
<!-- TODO: replace tabs with 4 spaces.  Default tab width is 8 an there's too
much scrolling -->
<div id="syntran_0" class="tabcontent">
{% highlight rust %}
fn get_bridge(g: [i32; :, :], num_adj: [i32; :]): [i32; :]
{
	// Stack for iterative (non-recursive) depth-first search
	let nn = size(num_adj, 0);
	let STACK_CAP = 16 * nn;
	let stack = [0; STACK_CAP];
	let sp = -1; // stack "pointer"

	// Push node 0 as root
	stack[(sp += 1)] = 0;

	let visited = [false; nn];
	let defer   = [false; nn];
	let parent  = [-1   ; nn];
	let low     = [-1   ; nn];
	let dists   = [-1   ; nn];

	let dist = 0;
	let found = false;
	let bridge = [-1, -1];
	while sp >= 0 and not found
	{
		let v = stack[(sp -= 1) + 1]; // pop
		if not visited[v]
		{
			low[v]   = dist;
			dists[v] = dist;
			dist += 1;
		}
		visited[v] = true;

		for iw in [0: num_adj[v]]
		{
			let w = g[iw, v];
			if w == parent[v]
			{
				// Do nothing
			}
			else if visited[w]
				low[v] = min(low[v], dists[w]);
			else
			{
				parent[w] = v;

				// re-push parent for deferred processing
				stack[(sp += 1)] = v;
				check_stack_cap(sp, STACK_CAP);
				defer[v] = true;

				// push child. order matters wrt parent
				stack[(sp += 1)] = w;
				check_stack_cap(sp, STACK_CAP);
			}
		}

		if defer[v]
		{
			for iw in [0: num_adj[v]]
			{
				let w = g[iw, v];
				if w != parent[v] and visited[w]
				{
					low[v] = min(low[v], low[w]);
					if (low[w] > dists[v])
					{
						bridge = [v, w];
						found = true;
					}
				}
			}
		}
	}
	let ans = bridge;
}
{% endhighlight %}
</div>

<div id="c_0" class="tabcontent">
{% highlight c %}
int* get_bridge(int* g, int* num_adj, int nn)
{
	// Stack for iterative (non-recursive) depth-first search
	int STACK_CAP = 16 * nn;
	int* stack = malloc(STACK_CAP * sizeof(int));
	memset(stack, 0, sizeof(stack));
	int sp = -1; // stack "pointer"

	// Push node 0 as root
	stack[(sp += 1)] = 0;

	bool* visited = malloc(nn * sizeof(bool));
	bool* defer   = malloc(nn * sizeof(bool));
	int*  parent  = malloc(nn * sizeof(int));
	int*  low     = malloc(nn * sizeof(int));
	int*  dists   = malloc(nn * sizeof(int));

	memset(visited, false, nn * sizeof(bool));
	memset(defer  , false, nn * sizeof(bool));
	memset(parent , -1   , nn * sizeof(int));
	memset(low    , -1   , nn * sizeof(int));
	memset(dists  , -1   , nn * sizeof(int));

	int dist = 0;
	bool found = false;
	int* bridge = malloc(2 * sizeof(int)); bridge[0] = -1; bridge[1] = -1;
	while (sp >= 0 && !found)
	{
		int v = stack[(sp -= 1) + 1]; // pop
		if (!visited[v])
		{
			low[v]   = dist;
			dists[v] = dist;
			dist += 1;
		}
		visited[v] = true;

		for (int iw = 0; iw < num_adj[v]; iw++)
		{
			int w = g[v * NADJ_CAP + iw];
			if (w == parent[v])
			{
				// Do nothing
			}
			else if (visited[w])
				low[v] = min(low[v], dists[w]);
			else
			{
				parent[w] = v;

				// Re-push parent for deferred processing
				stack[(sp += 1)] = v;
				//check_stack_cap(sp, STACK_CAP); // TODO
				defer[v] = true;

				// Push child. order matters wrt parent
				stack[(sp += 1)] = w;
				//check_stack_cap(sp, STACK_CAP); // TODO
			}
		}

		if (defer[v])
		{
			for (int iw = 0; iw < num_adj[v]; iw++)
			{
				int w = g[v * NADJ_CAP + iw];
				if ((w != parent[v]) && visited[w])
				{
					low[v] = min(low[v], low[w]);
					if (low[w] > dists[v])
					{
						bridge[0] = v; bridge[1] = w;
						found = true;
					}
				}
			}
		}
	}
	return bridge;
}
{% endhighlight %}
</div>

<script>
    function openTab(evt, tabName) {
        // Declare all variables
        var i, tabcontent, tablinks;

        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
    }

    // Show only default tab on page load
    document.getElementById("defaultOpen").click();

    // Change code block "figure" margins from ungodly 40px
    elems = document.getElementsByClassName("highlight");
    for (i = 0; i < elems.length; i++) {
        elems[i].style.margin = "0px";
        elems[i].style.tabSize = "4";
    }
</script>

