
<link rel="shortcut icon" type="image/png" href="favicon.png">

{% include header.md %}

# Abstract interfaces

## Swapping fractal iterator functions on the fly in Fortran

### 2021 Dec 11

Fractal images are generated by calling an *iterator function* many times on the 2D coordinates *c* for each pixel in the image.  Colors in the image are assigned depending on how many iterations it takes for a point to *escape* beyond a certain radius, if it escapes at all.

Two common fractals are the [Mandelbrot set](https://en.wikipedia.org/wiki/Mandelbrot_set) and the [burning ship fractal](https://en.wikipedia.org/wiki/Burning_Ship_fractal) (figures from wikipedia):

| ![](resources/mandelbrot.jpg) | ![](resources/burning-ship.png) |
| Figure 1a: the Mandelbrot set | Figure 1b: the burning ship fractal |

The only difference between these fractals is the iterator function.  For the Mandelbrot set, the iterator function is:

| (1) | ![](resources/mandelbrot-itr-func.svg) |

while for the burning ship, it is:

| (2) | ![](resources/burning-ship-itr-func.svg) |

Under the hood, pretty much everything about a program that creates a fractal image is the same as another program, regardless of the choice of fractal iterator function.

Thus, in accordance with the [DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), it makes sense to have a single program that can create fractal images for any iterator function, with as little redundancy as reasonable.

Now we are faced with a problem of how to swap out one iterator function for another at runtime.  A user may choose to define the iterator function either as Equation (1) or as Equation (2).  How can we set the function in a DRY and computationally efficient way?

The solution is [abstract interfaces](https://www.intel.com/content/www/us/en/develop/documentation/fortran-compiler-oneapi-dev-guide-and-reference/top/language-reference/a-to-z-reference/a-to-b/abstract-interface.html), [procedure pointers](https://www.intel.com/content/www/us/en/develop/documentation/fortran-compiler-oneapi-dev-guide-and-reference/top/language-reference/program-units-and-procedures/procedure-pointers.html), and [callbacks](https://en.wikipedia.org/wiki/Callback_(computer_programming)).

As a first step, let's define the iterator functions in Fortran:

{% highlight fortran %}
!=======================================================================

double complex function fmandelbrot(z, c)

double complex :: z, c

fmandelbrot = z ** 2 + c

end function fmandelbrot

!=======================================================================

double complex function fship(z, c)

! Burning ship

double complex :: z, c

fship = complex(abs(realpart(z)), abs(imagpart(z))) ** 2 + c

end function fship

!=======================================================================
{% endhighlight %}

Recall that in Fortran, the two-word keyword `double complex` means a complex number with each component having double the precision as a C `float`.

Notice any similarities in the functions? Aside from having similar equations of the form `y ** 2 + c` (where the `y` term may or may not get an `abs()` workout), these functions have the same signature.  That is, `fmandelbrot` and `fship` both have the same numbers of input arguments and output arguments, and the arguments are of the same types.  In this case, they have:
- 2 input arguments `z` and `c`
- 1 output argument (named after the respective function)
- all arguments are of the `double complex` type

Let's formalize that by defining an *abstract interface*:

{% highlight fortran %}
abstract interface

  double complex function itr_func_interface(z, c)
  double complex :: z, c
  end function itr_func_interface

end interface
{% endhighlight %}

After all, the compiler will need to know the interface before we can pass the function as a callback or swap out a function pointer for one function or another.  The abstract interface is how we define this function signature for the compiler.

TODO:  notes on dummy arg names, dummy function name

