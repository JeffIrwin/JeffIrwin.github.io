
{% include header.md %}

# Tarjan's bridge algorithm

## An iterative implementation

### 2024 Feb 04

## Tabs

<!-- Tab links -->
<div class="tab">
  <button class="tablinks" onclick="openTab(event, 'syntran_0')" id="defaultOpen">syntran</button>
  <button class="tablinks" onclick="openTab(event, 'c_0')">C</button>
</div>

<!-- Tab content -->
<!-- TODO: replace tabs with 4 spaces.  Default tab width is 8 an there's too
much scrolling -->
<div id="syntran_0" class="tabcontent">
{% highlight rust %}

    let sp = -1; // stack pointer

    // Push root
    stack[(sp += 1)] = 0;

    let visited = [false; nn];
    let defer   = [false; nn];
    let parent  = [-1; nn];
    let low     = [-1; nn];
    let tin     = [-1; nn];

    let timer = 0;

    // FIXME: implementations that I have seen online for Tarjan's algorithm
    // wrap the following loop in another `for` loop which iterates and pushes
    // every possible vertex.  I suppose this is just in case the graph
    // *already* has multiple disconnected components.  I don't think I need it
    // for AOC
    while sp >= 0
    {
        // pop
        let v = stack[(sp -= 1) + 1];
        //println("v = ", v, " = ", names[v]);

        if not visited[v]
        {
            low[v] = timer;
            tin[v] = timer;
            timer += 1;
        }
        visited[v] = true;

        for ito in [0: nadj[v]]
        {
            let to = g[ito, v];
            if to == parent[v]
            {
                // Do nothing
            }
            else if visited[to]
            {
                low[v] = min(low[v], tin[to]);
            }
            else
            {
                parent[to] = v;

                stack[(sp += 1)] = v;  // re-push parent for deferred processing
                defer[v] = true;

                stack[(sp += 1)] = to; // push child. order matters wrt parent
                // TODO: stack cap check
            }
        }

        if defer[v]
        {
            for ito in [0: nadj[v]]
            {
                let to = g[ito, v];
                if to != parent[v] and visited[to]
                {
                    low[v] = min(low[v], low[to]);
                    if (low[to] > tin[v])
                    {
                        //// TODO: this may log the same bridge multiple times.
                        //// Pushing to an equivalenced set is left as an exercise
                        //// for the reader
                        //println();
                        //println("****************");

                        //println("Found bridge = ", [v, to], " = ", [names[v], names[to]]);
                        //println();
                        //exit(0); // TODO
                    }
                }
            }
        }
    }
    //println("visited = ", visited);
    //println("parent = ", parent);
    //println("tin    = ", tin);
    //println("low  = ", low);

{% endhighlight %}
</div>

<div id="c_0" class="tabcontent">
{% highlight c %}
// TODO: implement Tarjan's bridge algorithm in C
printf("hello world");
{% endhighlight %}
</div>

<script>
    function openTab(evt, tabName) {
        // Declare all variables
        var i, tabcontent, tablinks;

        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
    }

    document.getElementById("defaultOpen").click();

</script>

